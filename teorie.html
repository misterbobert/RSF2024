<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <!--Bootstrap files-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <title>Teorie</title>
</head>
<body style="background: #283845">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
          <a class="navbar-brand" href="index.html">Acasă</a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item">
                <a class="nav-link active" aria-current="page" href="teorie.html">Teorie</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="criptare.html" >Criptează</a>
              </li>
              <li class="nav-item"></li>
                <a class="nav-link" href="register.html">Înregistrează-te</a>
              </li>
            </ul>
          </div>
        </div>
    </nav>
    <br>
    <div class="card center "style="width: 90%; background-color:#28242c;">
        <div class="card-body"> 
    <!--Cifrul lui Ceasar-->
    <div style="padding: 20px;">
        <h1>Algoritmul de criptare Caesar Cipher în C++</h1>

        <p>Acest cod C++ implementează un simplu cifru Caesar pentru criptare și decriptare a textului.</p>

        <h2>Codul C++:</h2>
        <button class="accordion">Cifrul lui Ceasar</button>
    <div class="panel">
    <pre><code>
    <span class="keyword">#include</span> &lt;iostream&gt;
    <span class="keyword">#include</span> &lt;string&gt;
    
    <span class="keyword">using namespace</span> std;
    
    <span class="comment">// Funcție pentru criptare</span>
    <span class="keyword">string</span> <span class="function">encrypt</span>(<span class="keyword">string</span> text, <span class="keyword">int</span> shift) {
        <span class="keyword">string</span> result = <span class="string">""</span>;
    
        <span class="comment">// Parcugem fiecare caracter din text</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length(); i++) {
            <span class="comment">// Criptăm doar literele mari și mici</span>
            <span class="keyword">if</span> (isupper(text[i])) {
                <span class="comment">// Pentru litere mari (A-Z)</span>
                result += <span class="keyword">char</span>(<span class="keyword">int</span>(text[i] + shift - <span class="number">65</span>) % <span class="number">26</span> + <span class="number">65</span>);
            }
            <span class="keyword">else if</span> (islower(text[i])) {
                <span class="comment">// Pentru litere mici (a-z)</span>
                result += <span class="keyword">char</span>(<span class="keyword">int</span>(text[i] + shift - <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>);
            }
            <span class="keyword">else</span> {
                <span class="comment">// Orice alt caracter rămâne neschimbat</span>
                result += text[i];
            }
        }
        <span class="keyword">return</span> result;
    }
    
    <span class="comment">// Funcție pentru decriptare (opusul criptării)</span>
    <span class="keyword">string</span> <span class="function">decrypt</span>(<span class="keyword">string</span> text, <span class="keyword">int</span> shift) {
        <span class="keyword">return</span> <span class="function">encrypt</span>(text, <span class="number">26</span> - shift);  <span class="comment">// Deplasăm invers</span>
    }
    
    <span class="keyword">int</span> <span class="function">main</span>() {
        <span class="keyword">string</span> text = <span class="string">"Salut Lume!"</span>; <span class="comment">// Textul de criptat</span>
        <span class="keyword">int</span> shift = <span class="number">4</span>; <span class="comment">// Cheia de criptare (deplasarea)</span>
    
        <span class="keyword">string</span> encrypted = <span class="function">encrypt</span>(text, shift);
        <span class="keyword">string</span> decrypted = <span class="function">decrypt</span>(encrypted, shift);
    
        <span class="function">cout</span> &lt;&lt; <span class="string">"Text original: "</span> &lt;&lt; text &lt;&lt; <span class="function">endl</span>;
        <span class="function">cout</span> &lt;&lt; <span class="string">"Text criptat: "</span> &lt;&lt; encrypted &lt;&lt; <span class="function">endl</span>;
        <span class="function">cout</span> &lt;&lt; <span class="string">"Text decriptat: "</span> &lt;&lt; decrypted &lt;&lt; <span class="function">endl</span>;
    
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    </code></pre>
    </div>
    <h2>Codul Python:</h2>
        <button class="accordion">Cifrul lui Ceasar</button>
    <div class="panel">
        <pre><code>
    <span class="keyword">def</span> <span class="function">caesar_cipher</span>(message, shift):
        <span class="comment"># Funcția pentru criptarea mesajului folosind cifra lui Caesar</span>
        encrypted_message = <span class="string">""</span>
        <span class="keyword">for</span> char <span class="keyword">in</span> message:
            <span class="keyword">if</span> char.<span class="function">isalpha</span>():
                shift_base = <span class="keyword">ord</span>(<span class="string">'a'</span>) <span class="keyword">if</span> char.<span class="function">islower</span>() <span class="keyword">else</span> <span class="keyword">ord</span>(<span class="string">'A'</span>)
                encrypted_char = <span class="keyword">chr</span>(<span class="keyword">ord</span>(char) - shift_base + shift) % <span class="number">26</span> + shift_base
                encrypted_message += encrypted_char
            <span class="keyword">else</span>:
                encrypted_message += char
        <span class="keyword">return</span> encrypted_message

    <span class="keyword"># Exemplu de utilizare</span>
    message = <span class="string">"Mesaj de test."</span>
    shift = <span class="number">3</span>
    encrypted = caesar_cipher(message, shift)
    print(<span class="string">"Mesaj criptat:"</span>, encrypted)
</code></pre>
</div>
    </div>

    <!--HEXA-->
    <div style="padding: 20px;">
        <h1>Algoritmul de criptare HEXA în C++</h1>

        <p>Acest cod C++ implementează un algoritm HEXA pentru criptare și decriptare a textului.</p>

        <h2>Codul C++:</h2>
        <button class="accordion">HEXA</button>
        <div class="panel">
        <pre><code>
    <span class="keyword">#include</span> &lt;iostream&gt;
    <span class="keyword">#include</span> &lt;sstream&gt;
    <span class="keyword">#include</span> &lt;iomanip&gt;
    <span class="keyword">#include</span> &lt;string&gt;
            
    <span class="keyword">using namespace</span> std;
            
    <span class="comment">// Funcție care convertește un șir de caractere într-o reprezentare hexazecimală</span>
    <span class="keyword">std::string</span> <span class="function">stringToHex</span>(<span class="keyword">const std::string&amp;</span> input) {
    <span class="keyword">std::stringstream</span> ss;
        ss &lt;&lt; std::hex &lt;&lt; std::setfill(<span class="string">'0'</span>);
        <span class="keyword">for</span> (<span class="keyword">const char&amp;</span> ch : input) {
            ss &lt;&lt; std::setw(<span class="number">2</span>) &lt;&lt; static_cast&lt;<span class="keyword">int</span>&gt;(static_cast&lt;<span class="keyword">unsigned char</span>&gt;(ch));
        }
        <span class="keyword">return</span> ss.str();
    }
            
    <span class="comment">// Funcție care convertește un șir de caractere hexazecimal înapoi în reprezentarea sa originală</span>
    <span class="keyword">std::string</span> <span class="function">hexToString</span>(<span class="keyword">const std::string&amp;</span> hexStr) {
        <span class="keyword">std::string</span> output;
        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; hexStr.length(); i += <span class="number">2</span>) {
            <span class="keyword">std::string</span> part = hexStr.substr(i, <span class="number">2</span>);
            <span class="keyword">char</span> ch = static_cast&lt;<span class="keyword">char</span>&gt;(std::stoi(part, <span class="keyword">nullptr</span>, <span class="number">16</span>));
            output.push_back(ch);
        }
        <span class="keyword">return</span> output;
    }
            
    <span class="comment">// Funcție de criptare/decriptare folosind XOR</span>
    <span class="keyword">std::string</span> <span class="function">xorEncryptDecrypt</span>(<span class="keyword">const std::string&amp;</span> input, <span class="keyword">char</span> key) {
        <span class="keyword">std::string</span> output = input;
        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; input.size(); ++i) {
            output[i] = input[i] ^ key; <span class="comment">// Aplică operația XOR cu cheia</span>
        }
        <span class="keyword">return</span> output;
    }
            
    <span class="comment">// Funcție de criptare</span>
    <span class="keyword">std::string</span> <span class="function">hexaEncrypt</span>(<span class="keyword">const std::string&amp;</span> message, <span class="keyword">char</span> key) {
        <span class="keyword">std::string</span> xorEncrypted = xorEncryptDecrypt(message, key); <span class="comment">// Pasul 1: Criptare XOR</span>
        <span class="keyword">return</span> stringToHex(xorEncrypted);  <span class="comment">// Pasul 2: Convertire în hexazecimal</span>
    }
            
    <span class="comment">// Funcție de decriptare</span>
    <span class="keyword">std::string</span> <span class="function">hexaDecrypt</span>(<span class="keyword">const std::string&amp;</span> hexMessage, <span class="keyword">char</span> key) {
        <span class="keyword">std::string</span> xorDecrypted = hexToString(hexMessage);  <span class="comment">// Pasul 1: Convertire din hexazecimal în șir normal</span>
        <span class="keyword">return</span> xorEncryptDecrypt(xorDecrypted, key);         <span class="comment">// Pasul 2: Decriptare XOR</span>
    }
            
    <span class="keyword">int</span> <span class="function">main</span>() {
        <span class="keyword">std::string</span> message;
        <span class="keyword">char</span> key;
                    
        <span class="comment">// Citim mesajul de criptat de la utilizator</span>
        <span class="function">std::cout</span> &lt;&lt; <span class="string">"Introdu mesajul pentru criptare: "</span>;
        <span class="function">std::getline</span>(std::cin, message);
            
        <span class="comment">// Citim cheia pentru criptare (un singur caracter)</span>
        <span class="function">std::cout</span> &lt;&lt; <span class="string">"Introdu cheia (un singur caracter): "</span>;
        <span class="function">std::cin</span> &gt;&gt; key;
            
        <span class="comment">// Criptăm mesajul</span>
        <span class="keyword">std::string</span> encrypted = hexaEncrypt(message, key);
        <span class="function">std::cout</span> &lt;&lt; <span class="string">"Mesaj criptat (Hexa Crypt): "</span> &lt;&lt; encrypted &lt;&lt; <span class="function">std::endl</span>;
            
        <span class="comment">// Decriptăm mesajul</span>
        <span class="keyword">std::string</span> decrypted = hexaDecrypt(encrypted, key);
        <span class="function">std::cout</span> &lt;&lt; <span class="string">"Mesaj decriptat (Mesaj original): "</span> &lt;&lt; decrypted &lt;&lt; <span class="function">std::endl</span>;
            
        <span class="keyword">return</span> <span class="number">0</span>;
    }
            </code></pre>
        </div>
        <h2>Python:</h2>
        <button class="accordion">HEXA</button>
        <div class="panel">
            <pre><code>
    <span class="keyword">def</span> <span class="function">string_to_hex</span>(input_string):
        <span class="comment"># Funcție care convertește un șir de caractere în hexazecimal</span>
        return <span class="keyword">''.join</span>(<span class="function">format</span>(ord(c), <span class="string">'02x'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> input_string)

    <span class="keyword">def</span> <span class="function">hex_to_string</span>(hex_string):
        <span class="comment"># Funcție care convertește un șir hexazecimal înapoi în caractere</span>
        return <span class="keyword">''.join</span>(<span class="keyword">chr</span>(int(hex_string[i:i + <span class="number">2</span>], <span class="number">16</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(0, <span class="keyword">len</span>(hex_string), <span class="number">2</span>))

    <span class="keyword"># Exemplu de utilizare</span>
    message = <span class="string">"Mesaj de test."</span>
    hex_value = string_to_hex(message)
    print(<span class="string">"Mesaj în hexazecimal:"</span>, hex_value)
    decrypted_message = hex_to_string(hex_value)
    print(<span class="string">"Mesaj decriptat:"</span>, decrypted_message)
</code></pre>
        </div>
        </div>

    <!--RSA-->
    <div style="padding: 20px;">
        <h1>RSA Simplificat în C++</h1>
        
        <p>Acest cod C++ implementează un algoritm simplificat pentru criptarea și decriptarea unui mesaj numeric folosind RSA.</p>

        <h2>Codul C++:</h2>
        <button class="accordion">RSA</button>
    <div class="panel">
    <pre><code>
    <span class="keyword">#include</span> &lt;iostream&gt;
    <span class="keyword">#include</span> &lt;cmath&gt;
    <span class="keyword">#include</span> &lt;cstdlib&gt;
    <span class="keyword">#include</span> &lt;ctime&gt;

    <span class="keyword">using</span> <span class="keyword">namespace</span> std;

    <span class="comment">// Funcție pentru a calcula cel mai mare divizor comun (GCD)</span>
    <span class="keyword">int</span> <span class="function">gcd</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
        <span class="keyword">while</span> (b != <span class="number">0</span>) {
            <span class="keyword">int</span> temp = b;
            b = a % b;
            a = temp;
        }
        <span class="keyword">return</span> a;
    }

    <span class="comment">// Funcție pentru a calcula (a^b) % c</span>
    <span class="keyword">long long</span> <span class="function">modExp</span>(<span class="keyword">long long</span> a, <span class="keyword">long long</span> b, <span class="keyword">long long</span> c) {
        <span class="keyword">long long</span> result = <span class="number">1</span>;
        a = a % c;
        <span class="keyword">while</span> (b > <span class="number">0</span>) {
            <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>)
                result = (result * a) % c;
            b = b / <span class="number">2</span>;
            a = (a * a) % c;
        }
        <span class="keyword">return</span> result;
    }

    <span class="comment">// Funcție pentru a găsi inversul modular al lui e mod phi(n) folosind metoda extinsă Euclid</span>
    <span class="keyword">int</span> <span class="function">modInverse</span>(<span class="keyword">int</span> e, <span class="keyword">int</span> phi) {
        <span class="keyword">int</span> t = <span class="number">0</span>, newT = <span class="number">1</span>;
        <span class="keyword">int</span> r = phi, newR = e;

        <span class="keyword">while</span> (newR != <span class="number">0</span>) {
            <span class="keyword">int</span> quotient = r / newR;
            <span class="keyword">int</span> tempT = t;
            t = newT;
            newT = tempT - quotient * newT;

            <span class="keyword">int</span> tempR = r;
            r = newR;
            newR = tempR - quotient * newR;
        }

        <span class="keyword">if</span> (t < <span class="number">0</span>)
            t += phi;

        <span class="keyword">return</span> t;
    }

    <span class="keyword">int</span> <span class="function">main</span>() {
        srand(time(<span class="number">0</span>));

        <span class="comment">// Alegerea a două numere prime (pentru simplificare, sunt numere mici)</span>
        <span class="keyword">int</span> p = <span class="number">61</span>;
        <span class="keyword">int</span> q = <span class="number">53</span>;

        <span class="comment">// Calcularea lui n = p * q</span>
        <span class="keyword">int</span> n = p * q;

        <span class="comment">// Calcularea funcției Euler φ(n) = (p-1) * (q-1)</span>
        <span class="keyword">int</span> phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>);

        <span class="comment">// Alegerea cheii publice e, unde 1 < e < φ(n) și gcd(e, φ(n)) = 1</span>
        <span class="keyword">int</span> e;
        <span class="keyword">do</span> {
            e = rand() % (phi - <span class="number">2</span>) + <span class="number">2</span>; <span class="comment">// e este ales aleator între 2 și phi - 1</span>
        } <span class="keyword">while</span> (<span class="function">gcd</span>(e, phi) != <span class="number">1</span>);

        <span class="comment">// Calcularea cheii private d, astfel încât (d * e) % φ(n) = 1</span>
        <span class="keyword">int</span> d = <span class="function">modInverse</span>(e, phi);

        <span class="comment">// Afișarea cheilor publice și private</span>
        <span class="function">cout</span> &lt;&lt; <span class="string">"Cheia publică: ("</span> &lt;&lt; e &lt;&lt; <span class="string">", "</span> &lt;&lt; n &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="function">endl</span>;
        <span class="function">cout</span> &lt;&lt; <span class="string">"Cheia privată: ("</span> &lt;&lt; d &lt;&lt; <span class="string">", "</span> &lt;&lt; n &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="function">endl</span>;

        <span class="comment">// Mesajul de criptat (un număr mai mic decât n)</span>
        <span class="keyword">int</span> mesaj;
        <span class="function">cout</span> &lt;&lt; <span class="string">"Introdu un mesaj numeric (mai mic decât "</span> &lt;&lt; n &lt;&lt; <span class="string">"):"</span>;
        <span class="function">cin</span> &gt;&gt; mesaj;

        <span class="comment">// Criptarea mesajului: C = M^e % n</span>
        <span class="keyword">int</span> criptat = <span class="function">modExp</span>(mesaj, e, n);
        <span class="function">cout</span> &lt;&lt; <span class="string">"Mesaj criptat: "</span> &lt;&lt; criptat &lt;&lt; <span class="function">endl</span>;

        <span class="comment">// Decriptarea mesajului: M = C^d % n</span>
        <span class="keyword">int</span> decriptat = <span class="function">modExp</span>(criptat, d, n);
        <span class="function">cout</span> &lt;&lt; <span class="string">"Mesaj decriptat: "</span> &lt;&lt; decriptat &lt;&lt; <span class="function">endl</span>;

        <span class="keyword">return</span> <span class="number">0</span>;
    }
    </code></pre>
    </div>
    <h2>Codul Python:</h2>
        <button class="accordion">RSA</button>
    <div class="panel">
        <pre><code>
    <span class="keyword">def</span> <span class="function">gcd</span>(a, b):
        <span class="comment"># Funcție pentru calculul celui mai mare divizor comun</span>
        <span class="keyword">while</span> b != <span class="number">0</span>:
            a, b = b, a % b
        <span class="keyword">return</span> a

    <span class="keyword">def</span> <span class="function">mod_inverse</span>(a, m):
        <span class="comment"># Funcție pentru calculul inversului modular</span>
        m0, x0, x1 = m, <span class{number}>0</span>, <span class{number}>1</span>
        <span class="keyword">while</span> a > <span{number}>1</span>:
            q = a // m
            m, a = a % m, m
            x0, x1 = x1 - q * x0, x0
        <span class="keyword">return</span> x1 + m0 <span class="keyword">if</span> x1 < <span class="number">0</span> <span class="keyword">else</span> x1

    <span class="keyword">def</span> <span class="function">rsa_encrypt</span>(plaintext, e, n):
        <span class="comment"># Funcție pentru criptarea mesajului folosind RSA</span>
        <span class="keyword">return</span> pow(plaintext, e, n)

    <span class="keyword">def</span> <span class="function">rsa_decrypt</span>(ciphertext, d, n):
        <span class="comment"># Funcție pentru decriptarea mesajului folosind RSA</span>
        <span class="keyword">return</span> pow(ciphertext, d, n)

    <span class="keyword"># Exemplu de utilizare</span>
    p = <span class="number">61</span>
    q = <span class="number">53</span>
    n = p * q
    phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)
    e = <span class="number">17</span> <span class="keyword"># Cheia publică</span>
    d = mod_inverse(e, phi)

    message = <span class="number">65</span> <span class="comment"># Mesaj de criptat</span>
    encrypted_message = rsa_encrypt(message, e, n)
    print(<span class="string">"Mesaj criptat:"</span>, encrypted_message)

    decrypted_message = rsa_decrypt(encrypted_message, d, n)
    print(<span class="string">"Mesaj decriptat:"</span>, decrypted_message)
</code></pre>
    </div>
    </div>

    <!--Blowfish-->
    <div style="padding: 20px;">
        <h1>Algoritmul Blowfish în C++</h1>

        <p>Acest cod C++ implementează algoritmul de criptare și decriptare Blowfish.</p>

        <h2>Codul C++:</h2>
        <button class="accordion">Blowfish</button>
    <div class="panel">
    <pre><code>
    <span class="keyword">#include</span> &lt;iostream&gt;
    <span class="keyword">#include</span> &lt;vector&gt;
    <span class="keyword">#include</span> &lt;cstring&gt; <span class="comment">// pentru memcpy</span>
    
    <span class="keyword">using namespace</span> std;
    
    <span class="comment">// Dimensiunea unui bloc în Blowfish (în biți)</span>
    <span class="keyword">const int</span> BLOCK_SIZE = <span class="number">8</span>;
    
    <span class="comment">// S-Box-uri pentru Blowfish (inițializate cu valori fictive, ar trebui inițializate corect conform specificației)</span>
    <span class="keyword">unsigned long</span> S[<span class="number">4</span>][<span class="number">256</span>] = {
        { <span class="comment">/* S-Box 1 valori */</span> },
        { <span class="comment">/* S-Box 2 valori */</span> },
        { <span class="comment">/* S-Box 3 valori */</span> },
        { <span class="comment">/* S-Box 4 valori */</span> }
    };
    
    <span class="comment">// P-array pentru Blowfish (valori inițiale, acestea vor fi modificate de cheie)</span>
    <span class="keyword">unsigned long</span> P[<span class="number">18</span>] = { 
        <span class="number">0x243F6A88</span>, <span class="number">0x85A308D3</span>, <span class="number">0x13198A2E</span>, <span class="number">0x03707344</span>,
        <span class="number">0xA4093822</span>, <span class="number">0x299F31D0</span>, <span class="number">0x082EFA98</span>, <span class="number">0xEC4E6C89</span>,
        <span class="number">0x452821E6</span>, <span class="number">0x38D01377</span>, <span class="number">0xBE5466CF</span>, <span class="number">0x34E90C6C</span>,
        <span class="number">0xC0AC29B7</span>, <span class="number">0xC97C50DD</span>, <span class="number">0x3F84D5B5</span>, <span class="number">0xB5470917</span>,
        <span class="number">0x9216D5D9</span>, <span class="number">0x8979FB1B</span>
    };
    
    <span class="comment">// Funcția F a algoritmului Blowfish</span>
    <span class="keyword">unsigned long</span> <span class="function">F</span>(<span class="keyword">unsigned long</span> x) {
        <span class="keyword">unsigned short</span> a, b, c, d;
        a = (x &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;
        b = (x &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;
        c = (x &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;
        d = x &amp; <span class="number">0xFF</span>;
    
        <span class="keyword">return</span> ((S[<span class="number">0</span>][a] + S[<span class="number">1</span>][b]) ^ S[<span class="number">2</span>][c]) + S[<span class="number">3</span>][d];
    }
    
    <span class="comment">// Cifrul Blowfish - rotirea blocurilor de date</span>
    <span class="keyword">void</span> <span class="function">BlowfishEncrypt</span>(<span class="keyword">unsigned long</span> &amp;left, <span class="keyword">unsigned long</span> &amp;right) {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) {
            left ^= P[i];
            right ^= <span class="function">F</span>(left);
            <span class="function">swap</span>(left, right);
        }
    
        <span class="function">swap</span>(left, right); <span class="comment">// Inversarea finală</span>
        right ^= P[<span class="number">16</span>];
        left ^= P[<span class="number">17</span>];
    }
    
    <span class="comment">// Decifrarea Blowfish - operația inversă cifrării</span>
    <span class="keyword">void</span> <span class="function">BlowfishDecrypt</span>(<span class="keyword">unsigned long</span> &amp;left, <span class="keyword">unsigned long</span> &amp;right) {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt; <span class="number">1</span>; i--) {
            left ^= P[i];
            right ^= <span class="function">F</span>(left);
            <span class="function">swap</span>(left, right);
        }
    
        <span class="function">swap</span>(left, right); <span class="comment">// Inversarea finală</span>
        right ^= P[<span class="number">1</span>];
        left ^= P[<span class="number">0</span>];
    }
    
    <span class="comment">// Inițializarea cheii în Blowfish</span>
    <span class="keyword">void</span> <span class="function">BlowfishKeyExpansion</span>(<span class="keyword">const vector&lt;unsigned char&gt;</span> &amp;key) {
        <span class="keyword">int</span> keyIndex = <span class="number">0</span>;
    
        <span class="comment">// XOR fiecare valoare din P-array cu cheia</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) {
            <span class="keyword">unsigned long</span> data = <span class="number">0x00000000</span>;
            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) {
                data = (data &lt;&lt; <span class="number">8</span>) | key[keyIndex];
                keyIndex = (keyIndex + <span class="number">1</span>) % key.size();
            }
            P[i] ^= data;
        }
    
        <span class="comment">// Criptarea blocurilor nule pentru a finaliza inițializarea</span>
        <span class="keyword">unsigned long</span> left = <span class="number">0x00000000</span>;
        <span class="keyword">unsigned long</span> right = <span class="number">0x00000000</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i += <span class="number">2</span>) {
            <span class="function">BlowfishEncrypt</span>(left, right);
            P[i] = left;
            P[i + <span class="number">1</span>] = right;
        }
    
        <span class="comment">// Inițializarea S-box-urilor (aceeași tehnică folosită pentru P-array)</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {
            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j += <span class="number">2</span>) {
                <span class="function">BlowfishEncrypt</span>(left, right);
                S[i][j] = left;
                S[i][j + <span class="number">1</span>] = right;
            }
        }
    }
    
    <span class="comment">// Funcție pentru a cripta un bloc de 64 de biți (8 octeți)</span>
    <span class="keyword">void</span> <span class="function">EncryptBlock</span>(<span class="keyword">unsigned char</span> *block) {
        <span class="keyword">unsigned long</span> left, right;
        <span class="function">memcpy</span>(&amp;left, block, <span class="number">4</span>);        <span class="comment">// Primele 4 octeți -> partea stângă</span>
        <span class="function">memcpy</span>(&amp;right, block + <span class="number">4</span>, <span class="number">4</span>);   <span class="comment">// Următorii 4 octeți -> partea dreaptă</span>
    
        <span class="function">BlowfishEncrypt</span>(left, right);
    
        <span class="function">memcpy</span>(block, &amp;left, <span class="number">4</span>);
        <span class="function">memcpy</span>(block + <span class="number">4</span>, &amp;right, <span class="number">4</span>);
    }
    
    <span class="comment">// Funcție pentru a decripta un bloc de 64 de biți (8 octeți)</span>
    <span class="keyword">void</span> <span class="function">DecryptBlock</span>(<span class="keyword">unsigned char</span> *block) {
        <span class="keyword">unsigned long</span> left, right;
        <span class="function">memcpy</span>(&amp;left, block, <span class="number">4</span>);        <span class="comment">// Primele 4 octeți -> partea stângă</span>
        <span class="function">memcpy</span>(&amp;right, block + <span class="number">4</span>, <span class="number">4</span>);   <span class="comment">// Următorii 4 octeți -> partea dreaptă</span>
    
        <span class="function">BlowfishDecrypt</span>(left, right);
    
        <span class="function">memcpy</span>(block, &amp;left, <span class="number">4</span>);
        <span class="function">memcpy</span>(block + <span class="number">4</span>, &amp;right, <span class="number">4</span>);
    }
    
    <span class="keyword">int</span> <span class="function">main</span>() {
        <span class="comment">// Cheia de criptare (exemplu)</span>
        <span class="keyword">vector&lt;unsigned char&gt;</span> key = { <span class="string">'K'</span>, <span class="string">'e'</span>, <span class="string">'y'</span>, <span class="string">'S'</span>, <span class="string">'e'</span>, <span class="string">'c'</span>, <span class="string">'r'</span>, <span class="string">'e'</span>, <span class="string">'t'</span> };
    
        <span class="comment">// Expansiunea cheii Blowfish</span>
        <span class="function">BlowfishKeyExpansion</span>(key);
    
        <span class="comment">// Exemplu de bloc de 8 octeți (64 de biți) de criptat</span>
        <span class="keyword">unsigned char</span> block[BLOCK_SIZE] = { <span class="string">'T'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'B'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'c'</span> };
    
        <span class="comment">// Afișarea blocului înainte de criptare</span>
        <span class="function">cout</span> &lt;&lt; <span class="string">"Bloc înainte de criptare: "</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BLOCK_SIZE; i++) {
            <span class="function">cout</span> &lt;&lt; block[i];
        }
        <span class="function">cout</span> &lt;&lt; <span class="function">endl</span>;
    
        <span class="comment">// Criptarea blocului</span>
        <span class="function">EncryptBlock</span>(block);
    
        <span class="comment">// Afișarea blocului după criptare</span>
        <span class="function">cout</span> &lt;&lt; <span class="string">"Bloc după criptare: "</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BLOCK_SIZE; i++) {
            <span class="function">printf</span>(<span class="string">"%02X "</span>, block[i]);
        }
        <span class="function">cout</span> &lt;&lt; <span class="function">endl</span>;
    
        <span class="comment">// Decriptarea blocului</span>
        <span class="function">DecryptBlock</span>(block);
    
        <span class="comment">// Afișarea blocului după decriptare</span>
        <span class="function">cout</span> &lt;&lt; <span class="string">"Bloc după decriptare: "</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BLOCK_SIZE; i++) {
            <span class="function">cout</span> &lt;&lt; block[i];
        }
        <span class="function">cout</span> &lt;&lt; <span class="function">endl</span>;
    
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    </code></pre>
    </div>
    <h2>Codul Python:</h2>
        <button class="accordion">Blowfish</button>
    <div class="panel">
    <pre><code>
    <span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> Blowfish
    <span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad

    <span class="keyword">def</span> <span class="function">blowfish_encrypt</span>(key, plaintext):
        <span class="comment"># Funcție de criptare folosind Blowfish</span>
        cipher = Blowfish.new(key, Blowfish.MODE_CBC)
        iv = cipher.iv
        ciphertext = cipher.encrypt(pad(plaintext.encode(), Blowfish.block_size))
        <span class="keyword">return</span> iv + ciphertext

    <span class="keyword">def</span> <span class="function">blowfish_decrypt</span>(key, ciphertext):
        <span class="comment"># Funcție de decriptare folosind Blowfish</span>
        iv = ciphertext[:Blowfish.block_size]
        cipher = Blowfish.new(key, Blowfish.MODE_CBC, iv)
        decrypted = unpad(cipher.decrypt(ciphertext[Blowfish.block_size:]), Blowfish.block_size)
        <span class="keyword">return</span> decrypted.decode()

    <span class="keyword"># Exemplu de utilizare</span>
    key = b'SecretK'  <span class="comment"># Cheie de criptare</span>
    plaintext = <span class="string">"Mesaj de test."</span>
    ciphertext = blowfish_encrypt(key, plaintext)
    print(<span class="string">"Mesaj criptat:"</span>, ciphertext)

    decrypted_message = blowfish_decrypt(key, ciphertext)
    print(<span class="string">"Mesaj decriptat:"</span>, decrypted_message)
    </code></pre>

        </div>
    </div>
    <!--AES-->
    <div style="padding: 20px;">
        <h1>Algoritmul de criptare AES în C++</h1>

        <p>Acest cod C++ implementează un algoritm AES pentru criptare și decriptare a textului.</p>

        <h2>Codul C++:</h2>
        <button class="accordion">AES</button>
    <div class="panel">
<pre><code>
    <span class="keyword">#include</span> &lt;iostream&gt;
    <span class="keyword">#include</span> &lt;string&gt;
    <span class="keyword">#include</span> &lt;openssl/aes.h&gt;
    <span class="keyword">#include</span> &lt;openssl/rand.h&gt;

    <span class="keyword">using namespace</span> std;

    <span class="comment">// Funcție pentru criptare AES</span>
    <span class="keyword">void</span> <span class="function">aesEncrypt</span>(<span class="keyword">const unsigned char*</span> input, <span class="keyword">unsigned char*</span> output, <span class="keyword">const unsigned char*</span> key) {
        AES_KEY encryptKey;
        AES_set_encrypt_key(key, <span class="number">128</span>, &encryptKey); <span class="comment">// Setăm cheia AES</span>
        AES_encrypt(input, output, &encryptKey); <span class="comment">// Criptăm folosind AES</span>
    }

    <span class="comment">// Funcție pentru decriptare AES</span>
    <span class="keyword">void</span> <span class="function">aesDecrypt</span>(<span class="keyword">const unsigned char*</span> input, <span class="keyword">unsigned char*</span> output, <span class="keyword">const unsigned char*</span> key) {
        AES_KEY decryptKey;
        AES_set_decrypt_key(key, <span class="number">128</span>, &decryptKey); <span class="comment">// Setăm cheia AES pentru decriptare</span>
        AES_decrypt(input, output, &decryptKey); <span class="comment">// Decriptăm folosind AES</span>
    }

    <span class="keyword">int</span> <span class="function">main</span>() {
        <span class="comment">// Cheia trebuie să fie de exact 16 octeți pentru AES-128</span>
        <span class="keyword">unsigned char</span> key[AES_BLOCK_SIZE] = {<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, 
                                               <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>, <span class="number">0x08</span>,
                                               <span class="number">0x09</span>, <span class="number">0x0A</span>, <span class="number">0x0B</span>, <span class="number">0x0C</span>,
                                               <span class="number">0x0D</span>, <span class="number">0x0E</span>, <span class="number">0x0F</span>, <span class="number">0x10</span>};

        <span class="keyword">unsigned char</span> input[AES_BLOCK_SIZE] = {<span class="string">'T'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, 
                                              <span class="string">'I'</span>, <span class="string">'n'</span>, <span class="string">'p'</span>, <span class="string">'u'</span>, 
                                              <span class="string">'t'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, 
                                              <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>};

        <span class="keyword">unsigned char</span> encryptedOutput[AES_BLOCK_SIZE];
        <span class="keyword">unsigned char</span> decryptedOutput[AES_BLOCK_SIZE];

        <span class="comment">// Criptare</span>
        aesEncrypt(input, encryptedOutput, key);
        <span class="function">cout</span> &lt;&lt; <span class="string">"Mesaj criptat: "</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AES_BLOCK_SIZE; i++) {
            <span class="function">printf</span>(<span class="string">"%02x "</span>, encryptedOutput[i]);
        }
        <span class="function">cout</span> &lt;&lt; <span class="function">endl</span>;

        <span class="comment">// Decriptare</span>
        aesDecrypt(encryptedOutput, decryptedOutput, key);
        <span class="function">cout</span> &lt;&lt; <span class="string">"Mesaj decriptat: "</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AES_BLOCK_SIZE; i++) {
            <span class="function">cout</span> &lt;&lt; decryptedOutput[i];
        }
        <span class="function">cout</span> &lt;&lt; <span class="function">endl</span>;

        <span class="keyword">return</span> <span class="number">0</span>;
    }
    </code></pre>
    </div>
    <h2>Python:</h2>
        <button class="accordion">AES</button>
    <div class="panel">
        <pre><code>
    <span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES
    <span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad

    <span class="keyword">def</span> <span class="function">aes_encrypt</span>(key, plaintext):
        <span class="comment"># Funcție de criptare folosind AES</span>
        cipher = AES.new(key, AES.MODE_CBC)
        iv = cipher.iv
        ciphertext = cipher.encrypt(pad(plaintext.encode(), AES.block_size))
        <span class="keyword">return</span> iv + ciphertext

    <span class="keyword">def</span> <span class="function">aes_decrypt</span>(key, ciphertext):
        <span class="comment"># Funcție de decriptare folosind AES</span>
        iv = ciphertext[:AES.block_size]
        cipher = AES.new(key, AES.MODE_CBC, iv)
        decrypted = unpad(cipher.decrypt(ciphertext[AES.block_size:]), AES.block_size)
        <span class="keyword">return</span> decrypted.decode()

    <span class="keyword"># Exemplu de utilizare</span>
    key = b'Sixteen byte key'  <span class="comment"># Cheie de 16 bytes pentru AES</span>
    plaintext = <span class="string">"Mesaj de test."</span>
    ciphertext = aes_encrypt(key, plaintext)
    print(<span class="string">"Mesaj criptat:"</span>, ciphertext)

    decrypted_message = aes_decrypt(key, ciphertext)
    print(<span class="string">"Mesaj decriptat:"</span>, decrypted_message)
    </code></pre>

    </div>
    </div>

    <!--ECC-->
    <div style="padding: 20px;">
        <h1>Algoritmul de criptare ECC în C++</h1>

        <p>Acest cod C++ implementează ECC pentru criptare și decriptare a textului.</p>

        <h2>Codul C++:</h2>
        <button class="accordion">ECC</button>
    <div class="panel">
    <pre><code>
    <span class="keyword">#include</span> &lt;iostream&gt;
    <span class="keyword">#include</span> &lt;utility&gt; <span class="comment">// pentru std::pair</span>
    <span class="keyword">#include</span> &lt;cmath&gt;   <span class="comment">// pentru funcții matematice de bază</span>

    <span class="keyword">using namespace</span> std;

    <span class="comment">// Structură pentru a reprezenta punctele pe curba eliptică</span>
    <span class="keyword">struct</span> Point {
        <span class="keyword">long long</span> x, y;
    };

    <span class="comment">// Parametrii curbei eliptice</span>
    <span class="keyword">struct</span> CurveParams {
        <span class="keyword">long long</span> a, b, p; <span class="comment">// a și b sunt coeficienții curbei y^2 = x^3 + ax + b, p este câmpul finit</span>
    };

    <span class="comment">// Funcție pentru a calcula inversul modular folosind Algoritmul Euclidian Extins</span>
    <span class="keyword">long long</span> <span class="function">modInverse</span>(<span class="keyword">long long</span> k, <span class="keyword">long long</span> p) {
        <span class="keyword">long long</span> t = <span class="number">0</span>, newT = <span class="number">1</span>;
        <span class="keyword">long long</span> r = p, newR = k;

        <span class="keyword">while</span> (newR != <span class="number">0</span>) {
            <span class="keyword">long long</span> quotient = r / newR;

            <span class="comment">// Actualizăm t și newT fără a folosi tie()</span>
            <span class="keyword">long long</span> tempT = newT;
            newT = t - quotient * newT;
            t = tempT;

            <span class="comment">// Actualizăm r și newR fără tie()</span>
            <span class="keyword">long long</span> tempR = newR;
            newR = r - quotient * newR;
            r = tempR;
        }

        <span class="keyword">if</span> (r > <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// Invers nu există</span>
        <span class="keyword">if</span> (t < <span class="number">0</span>) t += p;     <span class="comment">// Ajustăm valoarea t dacă este negativă</span>

        <span class="keyword">return</span> t;
    }

    <span class="comment">// Funcția pentru adunarea a două puncte pe o curbă eliptică</span>
    <span class="keyword">Point</span> <span class="function">addPoints</span>(<span class="keyword">Point</span> P, <span class="keyword">Point</span> Q, <span class="keyword">CurveParams</span> curve) {
        <span class="keyword">if</span> (P.x == Q.x && P.y == Q.y) {
            <span class="keyword">long long</span> s = (<span class="number">3</span> * P.x * P.x + curve.a) * <span class="function">modInverse</span>(<span class="number">2</span> * P.y, curve.p) % curve.p;
            <span class="keyword">long long</span> x_r = (s * s - <span class="number">2</span> * P.x) % curve.p;
            <span class="keyword">long long</span> y_r = (s * (P.x - x_r) - P.y) % curve.p;

            <span class="comment">// Ajustăm dacă rezultatul este negativ</span>
            <span class="keyword">if</span> (x_r < <span class="number">0</span>) x_r += curve.p;
            <span class="keyword">if</span> (y_r < <span class="number">0</span>) y_r += curve.p;

            <span class="keyword">return</span> {x_r, y_r};
        } <span class="keyword">else</span> {
            <span class="keyword">long long</span> s = (Q.y - P.y) * <span class="function">modInverse</span>(Q.x - P.x, curve.p) % curve.p;
            <span class="keyword">long long</span> x_r = (s * s - P.x - Q.x) % curve.p;
            <span class="keyword">long long</span> y_r = (s * (P.x - x_r) - P.y) % curve.p;

            <span class="comment">// Ajustăm dacă rezultatul este negativ</span>
            <span class="keyword">if</span> (x_r < <span class="number">0</span>) x_r += curve.p;
            <span class="keyword">if</span> (y_r < <span class="number">0</span>) y_r += curve.p;

            <span class="keyword">return</span> {x_r, y_r};
        }
    }

    <span class="comment">// Funcția pentru înmulțirea unui punct cu un scalar pe o curbă eliptică</span>
    <span class="keyword">Point</span> <span class="function">scalarMult</span>(<span class="keyword">Point</span> P, <span class="keyword">long long</span> k, <span class="keyword">CurveParams</span> curve) {
        <span class="keyword">Point</span> result = P;
        k = k - <span class="number">1</span>; <span class="comment">// Deja avem un punct, deci repetăm k-1 ori adunarea</span>
        <span class="keyword">while</span> (k > <span class="number">0</span>) {
            result = <span class="function">addPoints</span>(result, P, curve);
            k--;
        }
        <span class="keyword">return</span> result;
    }

    <span class="comment">// Funcția principală</span>
    <span class="keyword">int</span> <span class="function">main</span>() {
        <span class="comment">// Definim o curbă eliptică simplă: y^2 = x^3 + ax + b (mod p)</span>
        <span class="keyword">CurveParams</span> curve = {<span class="number">2</span>, <span class="number">3</span>, <span class="number">97</span>}; <span class="comment">// Exemplu: y^2 = x^3 + 2x + 3 (mod 97)</span>

        <span class="comment">// Punctul generator G de pe curbă</span>
        <span class="keyword">Point</span> G = {<span class="number">3</span>, <span class="number">6</span>}; <span class="comment">// Exemplu de punct de pe curbă</span>

        <span class="comment">// Cheia privată a destinatarului</span>
        <span class="keyword">long long</span> privateKey = <span class="number">7</span>; <span class="comment">// Exemplu de cheie privată</span>

        <span class="comment">// Cheia publică a destinatarului: PublicKey = privateKey * G</span>
        <span class="keyword">Point</span> publicKey = <span class="function">scalarMult</span>(G, privateKey, curve);

        <span class="comment">// Expeditorul alege o cheie aleatorie k pentru criptare</span>
        <span class="keyword">long long</span> k = <span class="number">5</span>; <span class="comment">// Cheie aleatorie</span>

        <span class="comment">// Calcularea punctului R = k * G</span>
        <span class="keyword">Point</span> R = <span class="function">scalarMult</span>(G, k, curve);

        <span class="comment">// Mesajul de criptat (reprezentat ca punct pe curba eliptică)</span>
        <span class="keyword">Point</span> M = {<span class="number">10</span>, <span class="number">22</span>}; <span class="comment">// Exemplu de mesaj ca punct de pe curbă</span>

        <span class="comment">// Criptarea mesajului: C1 = R, C2 = M + k * publicKey</span>
        <span class="keyword">Point</span> C1 = R;
        <span class="keyword">Point</span> C2 = <span class="function">addPoints</span>(M, <span class="function">scalarMult</span>(publicKey, k, curve), curve);

        <span class="comment">// Afișăm rezultatele criptării</span>
        <span class="function">cout</span> &lt;&lt; <span class="string">"Mesaj criptat:"</span> &lt;&lt; <span class="function">endl</span>;
        <span class="function">cout</span> &lt;&lt; <span class="string">"C1: ("</span> &lt;&lt; C1.x &lt;&lt; <span class="string">", "</span> &lt;&lt; C1.y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="function">endl</span>;
        <span class="function">cout</span> &lt;&lt; <span class="string">"C2: ("</span> &lt;&lt; C2.x &lt;&lt; <span class="string">", "</span> &lt;&lt; C2.y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="function">endl</span>;

        <span class="comment">// Decriptarea mesajului: M = C2 - privateKey * C1</span>
        <span class="keyword">Point</span> decryptedMessage = <span class="function">addPoints</span>(C2, <span class="function">scalarMult</span>(C1, privateKey, curve), curve);

        <span class="function">cout</span> &lt;&lt; <span class="string">"Mesaj decriptat: ("</span> &lt;&lt; decryptedMessage.x &lt;&lt; <span class="string">", "</span> &lt;&lt; decryptedMessage.y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="function">endl</span>;

        <span class="keyword">return</span> <span class="number">0</span>;
    }
</code></pre>

    </div>
    <h2>Codul Python:</h2>
        <button class="accordion">ECC</button>
    <div class="panel">
        <pre><code>
    <span class="keyword"># Definirea unei clase pentru a reprezenta punctele pe curba eliptică</span>
    <span class="keyword">class</span> Point:
        <span class="keyword">def</span> <span class="function">__init__</span>(self, x, y):
            self.x = x
            self.y = y

    <span class="keyword"># Parametrii curbei eliptice</span>
    <span class="keyword">class</span> CurveParams:
        <span class="keyword">def</span> <span class="function">__init__</span>(self, a, b, p):
            self.a = a  <span class="comment"># Coeficientul 'a' al curbei</span>
            self.b = b  <span class="comment"># Coeficientul 'b' al curbei</span>
            self.p = p  <span class="comment"># Modulo p (câmp finit)</span>

    <span class="keyword"># Funcție pentru a calcula inversul modular folosind Algoritmul Euclidian Extins</span>
    <span class="keyword">def</span> <span class="function">mod_inverse</span>(k, p):
        t, new_t = 0, 1
        r, new_r = p, k

        <span class="keyword">while</span> new_r != 0:
            quotient = r // new_r
            t, new_t = new_t, t - quotient * new_t
            r, new_r = new_r, r - quotient * new_r

        <span class="keyword">if</span> r > 1:
            <span class="keyword">return</span> -1  <span class="comment"># Invers nu există</span>
        <span class="keyword">if</span> t < 0:
            t += p
        <span class="keyword">return</span> t

    <span class="keyword"># Funcție pentru adunarea a două puncte pe o curbă eliptică</span>
    <span class="keyword">def</span> <span class="function">add_points</span>(P, Q, curve):
        <span class="keyword">if</span> P.x == Q.x and P.y == Q.y:
            s = (3 * P.x * P.x + curve.a) * <span class="function">mod_inverse</span>(2 * P.y, curve.p) % curve.p
            x_r = (s * s - 2 * P.x) % curve.p
            y_r = (s * (P.x - x_r) - P.y) % curve.p
        <span class="keyword">else</span>:
            s = (Q.y - P.y) * <span class="function">mod_inverse</span>(Q.x - P.x, curve.p) % curve.p
            x_r = (s * s - P.x - Q.x) % curve.p
            y_r = (s * (P.x - x_r) - P.y) % curve.p

        <span class="keyword">if</span> x_r < 0:
            x_r += curve.p
        <span class="keyword">if</span> y_r < 0:
            y_r += curve.p

        <span class="keyword">return</span> Point(x_r, y_r)

    <span class="keyword"># Funcție pentru înmulțirea unui punct cu un scalar pe o curbă eliptică</span>
    <span class="keyword">def</span> <span class="function">scalar_mult</span>(P, k, curve):
        result = P
        k -= 1
        <span class="keyword">while</span> k > 0:
            result = <span class="function">add_points</span>(result, P, curve)
            k -= 1
        <span class="keyword">return</span> result

    <span class="keyword"># Funcția principală</span>
    <span class="keyword">if</span> __name__ == "<span class="string">__main__</span>":

        <span class="comment"># Definim o curbă eliptică simplă: y^2 = x^3 + ax + b (mod p)</span>
        curve = CurveParams(2, 3, 97) <span class="comment"># Exemplu: y^2 = x^3 + 2x + 3 (mod 97)</span>

        <span class="comment"># Punctul generator G de pe curbă</span>
        G = Point(3, 6)

        <span class="comment"># Cheia privată a destinatarului</span>
        private_key = 7 <span class="comment"># Exemplu de cheie privată</span>

        <span class="comment"># Cheia publică a destinatarului: PublicKey = privateKey * G</span>
        public_key = <span class="function">scalar_mult</span>(G, private_key, curve)

        <span class="comment"># Expeditorul alege o cheie aleatorie k pentru criptare</span>
        k = 5

        <span class="comment"># Calcularea punctului R = k * G</span>
        R = <span class="function">scalar_mult</span>(G, k, curve)

        <span class="comment"># Mesajul de criptat (reprezentat ca punct pe curba eliptică)</span>
        M = Point(10, 22)

        <span class="comment"># Criptarea mesajului: C1 = R, C2 = M + k * publicKey</span>
        C1 = R
        C2 = <span class="function">add_points</span>(M, <span class="function">scalar_mult</span>(public_key, k, curve), curve)

        <span class="comment"># Afișăm rezultatele criptării</span>
        <span class="function">print</span>(<span class="string">"Mesaj criptat:"</span>)
        <span class="function">print</span>(f<span class="string">"C1: ({C1.x}, {C1.y})"</span>)
        <span class="function">print</span>(f<span class="string">"C2: ({C2.x}, {C2.y})"</span>)

        <span class="comment"># Decriptarea mesajului: M = C2 - privateKey * C1</span>
        decrypted_message = <span class="function">add_points</span>(C2, <span class="function">scalar_mult</span>(C1, private_key, curve), curve)

        <span class="function">print</span>(f<span class="string">"Mesaj decriptat: ({decrypted_message.x}, {decrypted_message.y})"</span>)
</code></pre>


        </div>
    </div>
     <!--TwoFish-->
     <div style="padding: 20px;">
        <h1>Algoritmul de criptare TwoFish în C++</h1>

        <p>Acest cod C++ implementează TwoFish pentru criptare și decriptare a textului.</p>

        <h2>Codul C++:</h2>
        <button class="accordion">TwoFish</button>
    <div class="panel">
      <pre><code>
    <span class="keyword">#include</span> &lt;iostream&gt;
    <span class="keyword">#include</span> &lt;string&gt;
    <span class="keyword">#include</span> &lt;cryptlib.h&gt;
    <span class="keyword">#include</span> &lt;twofish.h&gt;
    <span class="keyword">#include</span> &lt;hex.h&gt;
    <span class="keyword">#include</span> &lt;secblock.h&gt;
    <span class="keyword">#include</span> &lt;osrng.h&gt;

    <span class="keyword">using namespace</span> CryptoPP;
    <span class="keyword">using namespace</span> std;

    <span class="comment">// Funcție pentru criptare Twofish</span>
    <span class="keyword">string</span> <span class="function">twofishEncrypt</span>(<span class="keyword">const string&amp;</span> plainText, <span class="keyword">const SecByteBlock&amp;</span> key) {
        <span class="keyword">string</span> cipherText;
        AutoSeededRandomPool prng;
        
        <span class="comment">// Inițializare cu vector de inițializare</span>
        byte iv[Twofish::BLOCKSIZE];
        prng.GenerateBlock(iv, sizeof(iv));

        CBC_Mode&lt;Twofish&gt;::Encryption encryption;
        encryption.SetKeyWithIV(key, key.size(), iv);

        <span class="keyword">StringSource</span> ss1(plainText, <span class="keyword">true</span>, 
            <span class="keyword">new</span> StreamTransformationFilter(encryption, 
            <span class="keyword">new</span> StringSink(cipherText), BlockPaddingSchemeDef::PKCS_PADDING));

        <span class="comment">// Adăugăm IV-ul la începutul cifrului pentru a-l putea folosi la decriptare</span>
        <span class="keyword">string</span> cipherWithIV(reinterpret_cast&lt;<span class="keyword">const char*</span>&gt;(iv), Twofish::BLOCKSIZE);
        cipherWithIV += cipherText;

        <span class="keyword">return</span> cipherWithIV;
    }

    <span class="comment">// Funcție pentru decriptare Twofish</span>
    <span class="keyword">string</span> <span class="function">twofishDecrypt</span>(<span class="keyword">const string&amp;</span> cipherWithIV, <span class="keyword">const SecByteBlock&amp;</span> key) {
        <span class="keyword">string</span> plainText;
        
        <span class="comment">// Extragem IV-ul din începutul cifrului</span>
        byte iv[Twofish::BLOCKSIZE];
        std::memcpy(iv, cipherWithIV.data(), Twofish::BLOCKSIZE);

        <span class="comment">// Extragem restul textului criptat</span>
        <span class="keyword">string</span> cipherText = cipherWithIV.substr(Twofish::BLOCKSIZE);

        CBC_Mode&lt;Twofish&gt;::Decryption decryption;
        decryption.SetKeyWithIV(key, key.size(), iv);

        <span class="keyword">StringSource</span> ss2(cipherText, <span class="keyword">true</span>, 
            <span class="keyword">new</span> StreamTransformationFilter(decryption, 
            <span class="keyword">new</span> StringSink(plainText), BlockPaddingSchemeDef::PKCS_PADDING));

        <span class="keyword">return</span> plainText;
    }

    <span class="keyword">int</span> <span class="function">main</span>() {
        AutoSeededRandomPool prng;

        <span class="comment">// Definim cheia (16, 24 sau 32 octeți pentru Twofish)</span>
        SecByteBlock key(Twofish::DEFAULT_KEYLENGTH);
        prng.GenerateBlock(key, key.size());

        <span class="comment">// Mesajul pe care dorim să-l criptăm</span>
        <span class="keyword">string</span> plainText = <span class="string">"Mesajul secret pentru Twofish!"</span>;

        <span class="comment">// Criptăm mesajul</span>
        <span class="keyword">string</span> cipherText = twofishEncrypt(plainText, key);
        <span class="function">cout</span> &lt;&lt; <span class="string">"Mesaj criptat (Twofish): "</span> &lt;&lt; cipherText &lt;&lt; <span class="function">endl</span>;

        <span class="comment">// Decriptăm mesajul</span>
        <span class="keyword">string</span> decryptedText = twofishDecrypt(cipherText, key);
        <span class="function">cout</span> &lt;&lt; <span class="string">"Mesaj decriptat (Twofish): "</span> &lt;&lt; decryptedText &lt;&lt; <span class="function">endl</span>;

        <span class="keyword">return</span> <span class="number">0</span>;
    }
</code></pre>
</div>
<h2>Codul Python:</h2>
        <button class="accordion">TwoFish</button>
    <div class="panel">
        <pre><code>
    <span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> Twofish
    <span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad

    <span class="keyword">def</span> <span class="function">twofish_encrypt</span>(key, plaintext):
        <span class="comment"># Funcție de criptare folosind TwoFish</span>
        cipher = Twofish.new(key, Twofish.MODE_CBC)
        iv = cipher.iv
        ciphertext = cipher.encrypt(pad(plaintext.encode(), Twofish.block_size))
        <span class="keyword">return</span> iv + ciphertext

    <span class="keyword">def</span> <span class="function">twofish_decrypt</span>(key, ciphertext):
        <span class="comment"># Funcție de decriptare folosind TwoFish</span>
        iv = ciphertext[:Twofish.block_size]
        cipher = Twofish.new(key, Twofish.MODE_CBC, iv)
        decrypted = unpad(cipher.decrypt(ciphertext[Twofish.block_size:]), Twofish.block_size)
        <span class="keyword">return</span> decrypted.decode()

    <span class="keyword"># Exemplu de utilizare</span>
    key = b'Sixteen byte key'  <span class="comment"># Cheie de criptare</span>
    plaintext = <span class="string">"Mesaj de test."</span>
    ciphertext = twofish_encrypt(key, plaintext)
    print(<span class="string">"Mesaj criptat:"</span>, ciphertext)

    decrypted_message = twofish_decrypt(key, ciphertext)
    print(<span class="string">"Mesaj decriptat:"</span>, decrypted_message)
    </code></pre>

        </div>
</div>  

    <!--DES-->
    <div style="padding: 20px;">
        <h1>Algoritmul de criptare DES în C++</h1>

        <p>Acest cod C++ implementează DES pentru criptare și decriptare a textului.</p>

        <h2>Codul C++:</h2>
        <button class="accordion">DES</button>
    <div class="panel">
    <pre><code>
    <span class="keyword">#include</span> &lt;iostream&gt;
    <span class="keyword">#include</span> &lt;string&gt;
    <span class="keyword">#include</span> &lt;openssl/des.h&gt;

    <span class="keyword">using namespace</span> std;

    <span class="comment">// Funcție pentru criptare DES</span>
    <span class="keyword">void</span> <span class="function">desEncrypt</span>(<span class="keyword">const unsigned char*</span> input, <span class="keyword">unsigned char*</span> output, <span class="keyword">const_DES_cblock</span> key) {
        DES_key_schedule schedule;
        DES_set_key_checked(&key, &schedule); <span class="comment">// Setăm cheia DES</span>
        DES_ecb_encrypt((<span class="keyword">const_DES_cblock</span>*)input, (<span class="keyword">DES_cblock*</span>)output, &schedule, DES_ENCRYPT); <span class="comment">// Criptare DES</span>
    }

    <span class="comment">// Funcție pentru decriptare DES</span>
    <span class="keyword">void</span> <span class="function">desDecrypt</span>(<span class="keyword">const unsigned char*</span> input, <span class="keyword">unsigned char*</span> output, <span class="keyword">const_DES_cblock</span> key) {
        DES_key_schedule schedule;
        DES_set_key_checked(&key, &schedule); <span class="comment">// Setăm cheia DES pentru decriptare</span>
        DES_ecb_encrypt((<span class="keyword">const_DES_cblock</span>*)input, (<span class="keyword">DES_cblock*</span>)output, &schedule, DES_DECRYPT); <span class="comment">// Decriptare DES</span>
    }

    <span class="keyword">int</span> <span class="function">main</span>() {
        <span class="comment">// Cheia trebuie să fie de exact 8 octeți pentru DES</span>
        <span class="keyword">DES_cblock</span> key = {<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, 
                                  <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>, <span class="number">0x08</span>};

        <span class="keyword">unsigned char</span> input[<span class="number">8</span>] = {<span class="string">'M'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'a'</span>,
                                          <span class="string">'j'</span>, <span class="string">'T'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>};

        <span class="keyword">unsigned char</span> encryptedOutput[<span class="number">8</span>];
        <span class="keyword">unsigned char</span> decryptedOutput[<span class="number">8</span>];

        <span class="comment">// Criptare</span>
        desEncrypt(input, encryptedOutput, key);
        <span class="function">cout</span> &lt;&lt; <span class="string">"Mesaj criptat (DES): "</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
            <span class="function">printf</span>(<span class="string">"%02x "</span>, encryptedOutput[i]);
        }
        <span class="function">cout</span> &lt;&lt; <span class="function">endl</span>;

        <span class="comment">// Decriptare</span>
        desDecrypt(encryptedOutput, decryptedOutput, key);
        <span class="function">cout</span> &lt;&lt; <span class="string">"Mesaj decriptat (DES): "</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
            <span class="function">cout</span> &lt;&lt; decryptedOutput[i];
        }
        <span class="function">cout</span> &lt;&lt; <span class="function">endl</span>;

        <span class="keyword">return</span> <span class="number">0</span>;
    }
</code></pre>
</div>
<h2>Codul Python:</h2>
        <button class="accordion">DES</button>
    <div class="panel">
        <pre><code>
    <span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES
    <span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad

    <span class="keyword">def</span> <span class="function">des_encrypt</span>(key, plaintext):
        <span class="comment"># Funcție de criptare folosind DES</span>
        cipher = DES.new(key, DES.MODE_CBC)
        iv = cipher.iv
        ciphertext = cipher.encrypt(pad(plaintext.encode(), DES.block_size))
        <span class="keyword">return</span> iv + ciphertext

    <span class="keyword">def</span> <span class="function">des_decrypt</span>(key, ciphertext):
        <span class="comment"># Funcție de decriptare folosind DES</span>
        iv = ciphertext[:DES.block_size]
        cipher = DES.new(key, DES.MODE_CBC, iv)
        decrypted = unpad(cipher.decrypt(ciphertext[DES.block_size:]), DES.block_size)
        <span class="keyword">return</span> decrypted.decode()

    <span class="keyword"># Exemplu de utilizare</span>
    key = b'8bytekey'  <span class="comment"># Cheie de 8 bytes pentru DES</span>
    plaintext = <span class="string">"Mesaj de test."</span>
    ciphertext = des_encrypt(key, plaintext)
    print(<span class="string">"Mesaj criptat:"</span>, ciphertext)

    decrypted_message = des_decrypt(key, ciphertext)
    print(<span class="string">"Mesaj decriptat:"</span>, decrypted_message)
</code></pre>

        </div>
</div>

<!--Diffie-Hellman-->
<div style="padding: 20px;">
    <h1>Algoritmul de criptare Diffie-Hellman în C++</h1>

    <p>Acest cod C++ implementează algoritmul Diffie-Hellman pentru criptare și decriptare a textului.</p>

    <h2>Codul C++:</h2>
    <button class="accordion">Diffie-Hellman</button>
<div class="panel">
    <pre><code>
    <span class="keyword">#include</span> &lt;iostream&gt;
    <span class="keyword">#include</span> &lt;dh.h&gt;
    <span class="keyword">#include</span> &lt;osrng.h&gt;
    <span class="keyword">#include</span> &lt;nbtheory.h&gt;
    <span class="keyword">#include</span> &lt;hex.h&gt;
    <span class="keyword">#include</span> &lt;secblock.h&gt;

    <span class="keyword">using namespace</span> CryptoPP;
    <span class="keyword">using namespace</span> std;

    <span class="comment">// Funcție pentru generarea perechii de chei (privată și publică) folosind Diffie-Hellman</span>
    <span class="keyword">void</span> <span class="function">generateKeys</span>(DH&amp; dh, SecByteBlock&amp; privateKey, SecByteBlock&amp; publicKey) {
        AutoSeededRandomPool prng;

        <span class="comment">// Generăm cheia privată și cea publică</span>
        privateKey = SecByteBlock(dh.PrivateKeyLength());
        publicKey = SecByteBlock(dh.PublicKeyLength());
        dh.GenerateKeyPair(prng, privateKey, publicKey);
    }

    <span class="comment">// Funcție pentru calcularea cheii comune</span>
    <span class="keyword">SecByteBlock</span> <span class="function">computeSharedKey</span>(DH&amp; dh, <span class="keyword">const</span> SecByteBlock&amp; privateKey, <span class="keyword">const</span> SecByteBlock&amp; otherPublicKey) {
        AutoSeededRandomPool prng;
        SecByteBlock sharedKey(dh.AgreedValueLength());

        <span class="keyword">if</span> (!dh.Agree(sharedKey, privateKey, otherPublicKey)) {
            <span class="function">cerr</span> &lt;&lt; <span class="string">"Eșec în calcularea cheii comune!"</span> &lt;&lt; <span class="function">endl</span>;
            exit(1);
        }
        <span class="keyword">return</span> sharedKey;
    }

    <span class="comment">// Funcție pentru a converti o cheie în hexazecimal pentru a o putea vizualiza</span>
    <span class="keyword">string</span> <span class="function">keyToHex</span>(<span class="keyword">const</span> SecByteBlock&amp; key) {
        <span class="keyword">string</span> hexKey;
        HexEncoder encoder(<span class="keyword">new</span> StringSink(hexKey));
        encoder.Put(key, key.size());
        encoder.MessageEnd();
        <span class="keyword">return</span> hexKey;
    }

    <span class="keyword">int</span> <span class="function">main</span>() {
        <span class="comment">// Setări pentru parametrul DH</span>
        AutoSeededRandomPool prng;
        Integer p("0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
                  "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
                  "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
                  "E485B576625E7EC6F44C42E9A63A36210000000000090563");
        Integer g("2");

        <span class="comment">// Inițializăm obiectul Diffie-Hellman cu parametrul p și baza g</span>
        DH dh(p, g);

        <span class="comment">// Generăm chei pentru Alice</span>
        SecByteBlock alicePrivateKey, alicePublicKey;
        <span class="function">generateKeys</span>(dh, alicePrivateKey, alicePublicKey);
        
        <span class="comment">// Generăm chei pentru Bob</span>
        SecByteBlock bobPrivateKey, bobPublicKey;
        <span class="function">generateKeys</span>(dh, bobPrivateKey, bobPublicKey);

        <span class="comment">// Calculăm cheia comună pentru Alice</span>
        SecByteBlock aliceSharedKey = <span class="function">computeSharedKey</span>(dh, alicePrivateKey, bobPublicKey);
        
        <span class="comment">// Calculăm cheia comună pentru Bob</span>
        SecByteBlock bobSharedKey = <span class="function">computeSharedKey</span>(dh, bobPrivateKey, alicePublicKey);

        <span class="comment">// Conversia cheilor în hexazecimal pentru afișare</span>
        <span class="function">cout</span> &lt;&lt; <span class="string">"Cheia privată Alice (hex): "</span> &lt;&lt; <span class="function">keyToHex</span>(alicePrivateKey) &lt;&lt; <span class="function">endl</span>;
        <span class="function">cout</span> &lt;&lt; <span class="string">"Cheia publică Alice (hex): "</span> &lt;&lt; <span class="function">keyToHex</span>(alicePublicKey) &lt;&lt; <span class="function">endl</span>;
        <span class="function">cout</span> &lt;&lt; <span class="string">"Cheia comună Alice (hex): "</span> &lt;&lt; <span class="function">keyToHex</span>(aliceSharedKey) &lt;&lt; <span class="function">endl</span>;
        
        <span class="function">cout</span> &lt;&lt; <span class="string">"Cheia privată Bob (hex): "</span> &lt;&lt; <span class="function">keyToHex</span>(bobPrivateKey) &lt;&lt; <span class="function">endl</span>;
        <span class="function">cout</span> &lt;&lt; <span class="string">"Cheia publică Bob (hex): "</span> &lt;&lt; <span class="function">keyToHex</span>(bobPublicKey) &lt;&lt; <span class="function">endl</span>;
        <span class="function">cout</span> &lt;&lt; <span class="string">"Cheia comună Bob (hex): "</span> &lt;&lt; <span class="function">keyToHex</span>(bobSharedKey) &lt;&lt; <span class="function">endl</span>;

        <span class="keyword">return</span> <span class="number">0</span>;
    }
</code></pre>
</div>
<h2>Codul Python:</h2>
        <button class="accordion">Diffie-Hellman</button>
        <div class="panel">
            <pre><code>
    <span class="keyword">from</span> cryptography.hazmat.primitives.asymmetric <span class="keyword">import</span> dh
    <span class="keyword">from</span> cryptography.hazmat.primitives <span class="keyword">import</span> serialization
    <span class="keyword">from</span> cryptography.hazmat.backends <span class="keyword">import</span> default_backend
    <span class="keyword">import</span> binascii

    <span class="comment"># Funcție pentru generarea cheilor (privată și publică) folosind parametrii DH</span>
    <span class="keyword">def</span> <span class="function">generate_keys</span>(<span class="keyword">parameters</span>):
        <span class="comment"># Generăm cheia privată pentru utilizare în schimb</span>
        <span class="keyword">private_key</span> = parameters.generate_private_key()
        <span class="keyword">public_key</span> = private_key.public_key()
        <span class="keyword">return</span> private_key, public_key

    <span class="comment"># Funcție pentru calcularea cheii comune</span>
    <span class="keyword">def</span> <span class="function">compute_shared_key</span>(<span class="keyword">private_key</span>, <span class="keyword">other_public_key</span>):
        <span class="comment"># Generăm cheia comună</span>
        <span class="keyword">shared_key</span> = private_key.exchange(other_public_key)
        <span class="keyword">return</span> shared_key

    <span class="comment"># Funcție pentru a converti o cheie în hexazecimal pentru a o putea vizualiza</span>
    <span class="keyword">def</span> <span class="function">key_to_hex</span>(<span class="keyword">key</span>):
        <span class="keyword">return</span> binascii.hexlify(key).decode()

    <span class="comment"># Funcția principală</span>
    <span class="keyword">def</span> <span class="function">main</span>():
        <span class="comment"># Definirea parametrilor pentru DH</span>
        <span class="keyword">parameters</span> = dh.generate_parameters(generator=<span class="number">2</span>, key_size=<span class="number">2048</span>, backend=default_backend())

        <span class="comment"># Generăm chei pentru Alice</span>
        <span class="keyword">alice_private_key</span>, <span class="keyword">alice_public_key</span> = <span class="function">generate_keys</span>(parameters)

        <span class="comment"># Generăm chei pentru Bob</span>
        <span class="keyword">bob_private_key</span>, <span class="keyword">bob_public_key</span> = <span class="function">generate_keys</span>(parameters)

        <span class="comment"># Calculăm cheile comune</span>
        <span class="keyword">alice_shared_key</span> = <span class="function">compute_shared_key</span>(alice_private_key, bob_public_key)
        <span class="keyword">bob_shared_key</span> = <span class="function">compute_shared_key</span>(bob_private_key, alice_public_key)

        <span class="comment"># Conversia cheilor în hexazecimal pentru afișare</span>
        <span class="function">print</span>(<span class="string">"Cheia privată Alice (hex): "</span>, <span class="function">key_to_hex</span>(alice_private_key.private_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PrivateFormat.TraditionalOpenSSL)))
        
        <span class="function">print</span>(<span class="string">"Cheia publică Alice (hex): "</span>, <span class="function">key_to_hex</span>(alice_public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo)))
        
        <span class="function">print</span>(<span class="string">"Cheia comună Alice (hex): "</span>, <span class="function">key_to_hex</span>(alice_shared_key))

        <span class="function">print</span>(<span class="string">"Cheia privată Bob (hex): "</span>, <span class="function">key_to_hex</span>(bob_private_key.private_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PrivateFormat.TraditionalOpenSSL)))
        
        <span class="function">print</span>(<span class="string">"Cheia publică Bob (hex): "</span>, <span class="function">key_to_hex</span>(bob_public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo)))
        
        <span class="function">print</span>(<span class="string">"Cheia comună Bob (hex): "</span>, <span class="function">key_to_hex</span>(bob_shared_key))

    <span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
        <span class="function">main</span>()
</code></pre>
</div>
</div>

</div>
</div>
    <script>
        var acc = document.getElementsByClassName("accordion");
        var i;
        
        for (i = 0; i < acc.length; i++) {
          acc[i].addEventListener("click", function() {
            this.classList.toggle("active");
            var panel = this.nextElementSibling;
            if (panel.style.maxHeight) {
              panel.style.maxHeight = null;
            } else {
              panel.style.maxHeight = panel.scrollHeight + "px";
            } 
          });
        }
    </script>
</body>
</html>